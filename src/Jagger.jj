// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }
// Fonction principale
PARSER_BEGIN(Jagger)

package src;
import src.VisitorEvaluation;
import src.VisitorTypeChecker;
import java.io.*;

public class Jagger{
    private static Scope currentScope;
    public static void main(String args[]) throws ParseException, FileNotFoundException
    {
		Jagger parser;
		if(args.length!=0){
			File inputFile = new File(args[0]);
			InputStream input = new FileInputStream(inputFile);
        	parser = new Jagger(input);
		}else
			parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" | "\n" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < STR:  "\"" ((~["\n", "\r", "\""])*)? "\"">
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < PRINT: "print" >                         // Print function.
|   < LET: "let" >
|   < IN: "in" >
|   < END: "end" >
|   < ASSIGN: ":=" >
|   < TRUE: "true" >
|   < FALSE: "false" >
|   < IF: "if" >
|   < THEN: "then" >
|   < ELSE: "else" >
|   < VAR: "var" >
|   < ID: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9"])* > // Var id
}

// Main lopp: read expressions on a line until end of file.
//     mainloop â†’ (S)* <EOF>
void mainloop():
{ Expression a; }
{
    (
      (a=scope())
      {
            {
            System.out.println("\n>>> Process code...\n");
            System.out.println("=======================================");
            System.out.println("            Pretty Print               ");
            System.out.println("=======================================");
            VisitorPrettyPrint prettyPrint =new VisitorPrettyPrint();
            a.accept(prettyPrint);

            System.out.println("=======================================");
            System.out.println("                Binder                 ");
            System.out.println("=======================================");
            VisitorBinder binder = new VisitorBinder();
            a.accept(binder);
            if(binder.hasError()){
                System.out.println(binder.getError());
                break;
            }else System.out.println("OK.");

            System.out.println("=======================================");
            System.out.println("             Type Checker              ");
            System.out.println("=======================================");
            VisitorTypeChecker typeChecker = new VisitorTypeChecker();
            a.accept(typeChecker);
            if(typeChecker.hasError()){
                System.out.println(typeChecker.getError());
                break;
            }else System.out.println("OK.");

            System.out.println("=======================================");
            System.out.println("               Evaluator               ");
            System.out.println("=======================================");
            VisitorEvaluation evaluator = new VisitorEvaluation();
            a.accept(evaluator);

            }
      }
    )*
    <EOF>
}

// Scope (the axiom).
// S -> "let" (D)+ "in" St(,St)* "end"
Expression scope():
{Expression e; Scope s = new Scope(); currentScope=s;}
{
    <LET>
        (declaration())*
    <IN>
         e=statement(){s.addInstr(e);} ("," e=statement(){s.addInstr(e);})*
    <END>
     { return s; }
}

// Declaration (the axiom).
// D -> "var" <ID> ":=" R
void declaration():
{Token t;Expression e;}
{
    <VAR> t=<ID> <ASSIGN> e=relation()
     {currentScope.addVar(t.toString(), new VarDecl(t.toString(), e)); }
}

// Statement (the axiom).
// St -> P | T | R | S
Expression statement():
{Expression e;}
{
	(
	  e=print()
	| e=ternary()
	| e=relation()
	| e=scope()
	){return e;}
}

// Ternary (the axiom).
// T -> "if" R "then" R "else" R
Expression ternary():
{Expression a,b,c;}
{
    <IF> a=relation() <THEN> b=relation() <ELSE> c=relation()
     { return new TernOp(a,b,c); }
}

// Print (the axiom).
// P -> "print(" R ")"
Expression print():
{Expression e;}
{
    <PRINT> "(" e=relation()  ")" { return new Print(e); }
}

// Relation (the axiom).
// R -> (E|T) ('<'R | '>'R | '<='R | '>='R | '=='R | '<>'R)
Expression relation():
{ Expression a, b; }
{
	(a=expression() | a=ternary())
	(
	  "<" b=relation() { a = new Relation(a,b,RelationOperator.INF); } 
	| ">" b=relation() { a = new Relation(a,b,RelationOperator.SUP); }
	| "<=" b=relation() { a = new Relation(a,b,RelationOperator.INF_EQ); }
	| ">=" b=relation() { a = new Relation(a,b,RelationOperator.SUP_EQ); }
	| "=" b=relation() { a = new Relation(a,b,RelationOperator.EQ); }
	)? { return a; } 
}

// Expression (the axiom).
// E -> T ('+'T | '-'T | '||'T)*
Expression expression():
{ Expression a,b; }
{
    a=term()
    (
      "+" b=expression() { a = new BinOp(a,b,BinarOperator.PLUS); }
    | "-" b=expression() { a = new BinOp(a,b,BinarOperator.MINUS);}
	| "||" b=expression() { a = new BinOp(a,b,BinarOperator.OR);}
    )? { return a; }
}

// Term (the axiom).
// T -> F ('*'F | '/'F | '&&'F)*
Expression term():
{ Expression a,b; }
{
    a=factor()
    (
      "*" b=factor() { a = new BinOp(a,b,BinarOperator.MULT); }
    | "/" b=factor() { a = new BinOp(a,b,BinarOperator.DIV); }
	| "&&" b=factor() { a = new BinOp(a,b,BinarOperator.AND);}
    )* { return a; }
}

// Factor (the axiom).
// F -> <NUMBER> | <BOOLEAN> | "(" R ")" | '+'F | '-'F | '!'F
Expression factor():
{ Token t; Expression e;}
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
    | t=<ID> { return new Var(t.toString());}
    | t=<STR>  { return new Str(t.toString()); }
	| <TRUE> { return new Num(1.0);}
	| <FALSE> { return new Num(0.0);}
	| "(" e=relation() ")" { return e; }
	| ("+")+  e=factor() {return new BinOp(new Num(0.0), e, BinarOperator.PLUS);}
	| ("-")+  e=factor() {return new BinOp(new Num(0.0), e, BinarOperator.MINUS);}
	| "<>"   e=factor() {return new Not(e);}
}
