// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }
// Fonction principale
PARSER_BEGIN(Jagger)

import java.io.*;
public class Jagger
{
    public static void main(String args[]) throws ParseException, FileNotFoundException
    {
		Jagger parser;
		if(args.length!=0){
			File inputFile = new File(args[0]);
			InputStream input = new FileInputStream(inputFile);
        	parser = new Jagger(input);
		}else
			parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|	< BOOLEAN: "true" | "false" >			  // A boolean.
|   < EOL: "\n" >                             // End of line.
}

// Main lopp: read expressions on a line until end of file.
//     mainloop â†’ (expression <EOL>)* <EOF>
void mainloop():
{ Expression a; }
{
    (
      a=relation() <EOL> {VisitorPrettyPrint v=new VisitorPrettyPrint();
	  						a.accept(v);
							System.out.println();
							VisitorEvaluation vv = new VisitorEvaluation();
							double d = a.accept(vv);
							System.out.println(d);
							}
    )*
    <EOF>
}

// Expression (the axiom).
// R -> E ('<'E | '>'E | '<='E | '>='E | '=='E | '<>'E)
Expression relation():
{ Expression a, b; }
{
	a=expression()
	(
	  "<" b=relation() { a = new Relation(a,b,RelationOperator.INF); } 
	| ">" b=relation() { a = new Relation(a,b,RelationOperator.SUP); }
	| "<=" b=relation() { a = new Relation(a,b,RelationOperator.INF_EQ); }
	| ">=" b=relation() { a = new Relation(a,b,RelationOperator.SUP_EQ); }
	| "==" b=relation() { a = new Relation(a,b,RelationOperator.EQ); }
	| "<>" b=relation() { a = new Not(new Relation(a,b,RelationOperator.EQ)); }
	)? { return a; } 
}

// Expression (the axiom).
// E -> T ('+'T | '-'T | '||'T)*
Expression expression():
{ Expression a,b; }
{
    a=term()
    (
      "+" b=expression() { a = new BinOp(a,b,BinarOperator.PLUS); }
    | "-" b=expression() { a = new BinOp(a,b,BinarOperator.MINUS);}
	| "||" b=expression() { a = new BinOp(a,b,BinarOperator.OR);}
    )? { return a; }
}

// Term.
// T -> F ('*'F | '/'F | '&&'F)*
Expression term():
{ Expression a,b; }
{
    a=factor()
    (
      "*" b=factor() { a = new BinOp(a,b,BinarOperator.MULT); }
    | "/" b=factor() { a = new BinOp(a,b,BinarOperator.DIV); }
	| "&&" b=expression() { a = new BinOp(a,b,BinarOperator.AND);}
    )* { return a; }
}


// Factor of an expression.
// F -> <NUMBER> | <BOOLEAN> | "(" +E ")" | "(" -E ")" | '+'F | '-'F | '!'F
Expression factor():
{ Token t; Expression e;}
{
      t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
	| "(" e=relation() ")" { return e; }
	| ("-")+  e=factor() {return new BinOp(new Num(0.0), e, BinarOperator.MINUS);}
	| ("+")+  e=factor() {return new BinOp(new Num(0.0), e, BinarOperator.PLUS);}
	| "!"   e=factor() {return new Not(e);}
	| t=<BOOLEAN> { return new Bool(Boolean.parseBoolean(t.toString()));}
}
